# Cursor Rules for Stock Market Analysis Project

## üéØ **Core Principles**

1. **Always README First**: Before performing any task, read through ALL README.md files to understand the current project state
2. **Documentation-Driven Development**: Every change must be reflected in appropriate README files
3. **Consistency**: Maintain consistent formatting, structure, and information across all documentation
4. **Completeness**: Ensure all technical details, configurations, and procedures are documented

## üìö **Required Documentation Review**

### **Before Every Task**
1. **Read main README.md** - Understand project overview, architecture, and current status
2. **Read component READMEs** - Review frontend/README.md, backend/README.md, database/README.md
3. **Read DOCKER_README.md** - Understand containerization and deployment setup
4. **Read PROJECT_RESTRUCTURING_CONTEXT.md** - Know project history and current structure

### **Documentation Hierarchy**
```
README.md (Main project documentation)
‚îú‚îÄ‚îÄ frontend/README.md (Frontend component details)
‚îú‚îÄ‚îÄ backend/README.md (Backend component details)
‚îú‚îÄ‚îÄ database/README.md (Database schema and management)
‚îú‚îÄ‚îÄ DOCKER_README.md (Containerization and DevOps)
‚îî‚îÄ‚îÄ PROJECT_RESTRUCTURING_CONTEXT.md (Project history and status)
```

## üîÑ **Documentation Update Workflow**

### **When Making Changes**
1. **Identify Impact**: Determine which README files need updates
2. **Update Content**: Modify relevant documentation sections
3. **Verify Consistency**: Ensure information is consistent across all files
4. **Commit Changes**: Include documentation updates in the same commit as code changes

### **Update Triggers**
- **Code Changes**: New features, bug fixes, refactoring
- **Configuration Changes**: Environment variables, ports, dependencies
- **Architecture Changes**: New components, services, or integrations
- **Process Changes**: Build steps, deployment procedures, development workflows

## üìù **Documentation Standards**

### **File Structure**
- **Clear Headers**: Use consistent header hierarchy (##, ###, ####)
- **Code Blocks**: Proper syntax highlighting and formatting
- **Links**: Internal links between related documentation sections
- **Examples**: Include practical examples and code snippets

### **Content Requirements**
- **Current Status**: Always reflect the actual current state
- **Version Information**: Keep version numbers and dates updated
- **Dependencies**: Document all package versions and requirements
- **Configuration**: Include all necessary configuration steps
- **Troubleshooting**: Document common issues and solutions

## üöÄ **Task Execution Protocol**

### **Step 1: Documentation Review**
```bash
# Always start by reading these files:
1. README.md - Main project documentation
2. frontend/README.md - Frontend component details
3. backend/README.md - Backend component details
4. database/README.md - Database schema and management
5. DOCKER_README.md - Containerization setup
6. PROJECT_RESTRUCTURING_CONTEXT.md - Project history
```

### **Step 2: Task Analysis**
- **Understand Requirements**: What needs to be accomplished?
- **Identify Scope**: Which components are affected?
- **Plan Documentation Updates**: Which README files need changes?

### **Step 3: Implementation**
- **Make Code Changes**: Implement the requested functionality
- **Update Documentation**: Modify relevant README files
- **Verify Consistency**: Ensure all documentation is aligned

### **Step 4: Validation**
- **Test Functionality**: Verify the changes work as expected
- **Review Documentation**: Check that all updates are accurate
- **Commit Changes**: Include both code and documentation updates

## üîç **Specific Documentation Areas**

### **Frontend Changes**
- **Update frontend/README.md** with:
  - New components or pages
  - Updated dependencies
  - Configuration changes
  - Build process modifications

### **Backend Changes**
- **Update backend/README.md** with:
  - New API endpoints
  - Database schema changes
  - Configuration updates
  - Performance optimizations

### **Database Changes**
- **Update database/README.md** with:
  - Schema modifications
  - New tables or views
  - Migration procedures
  - Performance improvements

### **Docker/DevOps Changes**
- **Update DOCKER_README.md** with:
  - New services or containers
  - Configuration changes
  - Build process updates
  - Deployment procedures

### **Project-Wide Changes**
- **Update main README.md** with:
  - Architecture changes
  - New features or capabilities
  - Updated quick start procedures
  - Modified project structure

## üìä **Documentation Quality Checklist**

### **Before Committing**
- [ ] All relevant README files have been updated
- [ ] Information is consistent across all documentation
- [ ] Examples and code snippets are current and working
- [ ] Version numbers and dates are updated
- [ ] Links between documentation files are working
- [ ] Configuration steps are complete and accurate
- [ ] Troubleshooting sections cover new issues

### **Content Validation**
- [ ] Technical details are accurate and current
- [ ] Step-by-step procedures are complete
- [ ] Code examples are syntax-correct and functional
- [ ] Configuration files reflect actual project state
- [ ] Dependencies and versions are current
- [ ] Port numbers and URLs are correct

## üö® **Common Documentation Pitfalls**

### **Avoid These Issues**
1. **Outdated Information**: Don't leave old configuration details
2. **Inconsistent Naming**: Use consistent terminology across all files
3. **Missing Examples**: Always provide practical usage examples
4. **Broken Links**: Ensure internal documentation links work
5. **Incomplete Procedures**: Don't leave steps incomplete

### **Best Practices**
1. **Update as You Go**: Don't wait until the end to update documentation
2. **Test Examples**: Verify that code examples actually work
3. **Cross-Reference**: Link related information between files
4. **Version Control**: Include documentation updates in the same commits as code changes

## üîß **Automated Documentation Tasks**

### **Regular Maintenance**
- **Weekly**: Review and update version numbers
- **Monthly**: Verify all links and examples are working
- **Quarterly**: Comprehensive review of all documentation
- **On Release**: Update all version information and release notes

### **Change Detection**
- **Package.json Changes**: Update dependency documentation
- **Docker Changes**: Update containerization documentation
- **API Changes**: Update backend and API documentation
- **UI Changes**: Update frontend and user interface documentation

## üìã **Task-Specific Rules**

### **For New Features**
1. Read all README files to understand current state
2. Implement the feature
3. Update relevant component README files
4. Update main README.md if it's a major feature
5. Update PROJECT_RESTRUCTURING_CONTEXT.md with new status

### **For Bug Fixes**
1. Read relevant README files to understand the issue
2. Fix the bug
3. Update troubleshooting sections if needed
4. Update any configuration documentation if changed

### **For Refactoring**
1. Read all README files to understand current architecture
2. Perform the refactoring
3. Update all affected documentation sections
4. Ensure new structure is properly documented

### **For Configuration Changes**
1. Read relevant README files to understand current configuration
2. Make the configuration change
3. Update all documentation that references the old configuration
4. Update examples and procedures as needed

## üéØ **Success Metrics**

### **Documentation Quality**
- **Completeness**: All features and procedures are documented
- **Accuracy**: Information matches actual project state
- **Consistency**: Terminology and format are consistent across files
- **Usability**: Documentation is easy to follow and understand

### **Maintenance**
- **Timeliness**: Documentation is updated with code changes
- **Version Control**: Documentation changes are committed with code
- **Review Process**: Regular documentation reviews are performed
- **User Feedback**: Documentation addresses user needs and questions

---

## üé® **Expert-Level Development Standards**

### **Frontend (React + TypeScript) Best Practices**

#### **React 18+ Patterns**
- **Functional Components**: Use functional components with hooks, avoid class components
- **Custom Hooks**: Extract reusable logic into custom hooks with descriptive names
- **Context API**: Use React Context for global state, avoid prop drilling
- **Strict Mode**: Enable React.StrictMode for development builds
- **Error Boundaries**: Implement error boundaries for graceful error handling
- **Suspense**: Use React.Suspense for lazy loading and data fetching

#### **TypeScript Excellence**
- **Strict Mode**: Enable all strict TypeScript compiler options
- **Type Definitions**: Create comprehensive interfaces and types for all data structures
- **Generic Types**: Use generics for reusable, type-safe components
- **Union Types**: Leverage union types for flexible but safe APIs
- **Utility Types**: Use TypeScript utility types (Partial, Pick, Omit, etc.)
- **No Any**: Avoid `any` type, use `unknown` or proper typing instead

#### **State Management**
- **Local State**: Use `useState` for component-local state
- **Complex State**: Use `useReducer` for complex state logic
- **Context**: Use Context API for theme, user preferences, global settings
- **External State**: Consider Zustand or Redux Toolkit for complex global state
- **State Updates**: Always use functional updates for state that depends on previous values

#### **Performance Optimization**
- **React.memo**: Memoize components that receive stable props
- **useMemo**: Memoize expensive calculations
- **useCallback**: Memoize callback functions passed to child components
- **Lazy Loading**: Use React.lazy and Suspense for code splitting
- **Virtual Scrolling**: Implement virtual scrolling for large lists
- **Bundle Analysis**: Regular bundle analysis and optimization

#### **Component Architecture**
- **Single Responsibility**: Each component should have one clear purpose
- **Composition**: Prefer composition over inheritance
- **Props Interface**: Define clear, minimal props interfaces
- **Default Props**: Use default props for optional values
- **Prop Validation**: Use TypeScript for runtime prop validation

### **Backend (Node.js + Express) Best Practices**

#### **Node.js Excellence**
- **Async/Await**: Use async/await instead of callbacks or promises
- **Error Handling**: Implement comprehensive error handling with try-catch
- **Streaming**: Use streams for large file operations and real-time data
- **Memory Management**: Monitor memory usage and implement garbage collection optimization
- **Cluster Mode**: Use Node.js cluster for multi-core utilization in production

#### **Express.js Patterns**
- **Middleware Chain**: Organize middleware in logical order
- **Route Organization**: Group related routes in separate files
- **Error Middleware**: Implement global error handling middleware
- **Request Validation**: Validate all incoming requests with Joi or similar
- **Response Formatting**: Standardize API response formats
- **Rate Limiting**: Implement rate limiting for API endpoints

#### **API Design**
- **RESTful Principles**: Follow REST conventions for API design
- **Versioning**: Implement API versioning strategy
- **Pagination**: Use cursor-based pagination for large datasets
- **Filtering**: Implement flexible filtering and sorting
- **Caching**: Use Redis or in-memory caching for frequently accessed data
- **Documentation**: Auto-generate API documentation with Swagger/OpenAPI

#### **Security Best Practices**
- **Input Validation**: Validate and sanitize all inputs
- **SQL Injection**: Use parameterized queries, never concatenate SQL
- **Authentication**: Implement JWT or session-based authentication
- **Authorization**: Use role-based access control (RBAC)
- **HTTPS**: Always use HTTPS in production
- **Security Headers**: Implement security headers with Helmet.js

### **Database (SQLite3) Best Practices**

#### **Schema Design**
- **Normalization**: Follow database normalization principles
- **Indexing Strategy**: Create strategic indexes for query performance
- **Constraints**: Use foreign keys, check constraints, and unique constraints
- **Views**: Create views for complex, frequently-used queries
- **Stored Procedures**: Use prepared statements for complex operations

#### **Performance Optimization**
- **Query Optimization**: Write efficient SQL queries with proper JOINs
- **Index Usage**: Monitor index usage and create missing indexes
- **Connection Pooling**: Implement connection pooling for concurrent access
- **Transaction Management**: Use transactions for data consistency
- **Batch Operations**: Use batch inserts/updates for large datasets

#### **Data Integrity**
- **ACID Compliance**: Ensure transactions are atomic, consistent, isolated, and durable
- **Backup Strategy**: Implement regular database backups
- **Migration System**: Use versioned database migrations
- **Data Validation**: Validate data at both application and database levels

### **DevOps & Infrastructure Best Practices**

#### **Docker Excellence**
- **Multi-stage Builds**: Use multi-stage builds for optimized images
- **Layer Caching**: Optimize Docker layer caching for faster builds
- **Security Scanning**: Scan images for vulnerabilities
- **Resource Limits**: Set appropriate CPU and memory limits
- **Health Checks**: Implement comprehensive health checks

#### **CI/CD Pipeline**
- **Automated Testing**: Run tests on every commit
- **Code Quality**: Use ESLint, Prettier, and TypeScript compiler checks
- **Security Scanning**: Integrate security scanning in the pipeline
- **Deployment Strategy**: Use blue-green or rolling deployments
- **Monitoring**: Implement comprehensive logging and monitoring

### **Code Quality Standards**

#### **Code Organization**
- **File Structure**: Organize code by feature, not by type
- **Naming Conventions**: Use descriptive, consistent naming
- **File Size**: Keep files under 300 lines when possible
- **Function Length**: Keep functions under 50 lines
- **Class Size**: Keep classes focused and small

#### **Code Review Standards**
- **Readability**: Code should be self-documenting
- **Performance**: Consider performance implications
- **Security**: Review for security vulnerabilities
- **Testing**: Ensure adequate test coverage
- **Documentation**: Verify inline documentation

#### **Testing Strategy**
- **Unit Tests**: 80%+ code coverage for critical paths
- **Integration Tests**: Test component interactions
- **E2E Tests**: Test critical user journeys
- **Performance Tests**: Test under load conditions
- **Security Tests**: Regular security testing

### **Performance & Scalability**

#### **Frontend Performance**
- **Bundle Optimization**: Minimize bundle size with tree shaking
- **Lazy Loading**: Implement lazy loading for routes and components
- **Image Optimization**: Use WebP format and responsive images
- **Caching Strategy**: Implement effective caching strategies
- **CDN Usage**: Use CDN for static assets

#### **Backend Performance**
- **Database Optimization**: Optimize database queries and indexes
- **Caching Layers**: Implement multiple caching layers
- **Load Balancing**: Use load balancing for horizontal scaling
- **Microservices**: Consider microservices for complex applications
- **Monitoring**: Implement comprehensive performance monitoring

### **Security Considerations**

#### **Frontend Security**
- **XSS Prevention**: Sanitize user inputs and use Content Security Policy
- **CSRF Protection**: Implement CSRF tokens for state-changing operations
- **Secure Storage**: Never store sensitive data in localStorage
- **HTTPS Only**: Ensure all communications use HTTPS

#### **Backend Security**
- **Input Validation**: Validate all inputs at multiple layers
- **Authentication**: Implement secure authentication mechanisms
- **Authorization**: Use principle of least privilege
- **Data Encryption**: Encrypt sensitive data at rest and in transit
- **Audit Logging**: Log all security-relevant events

### **Monitoring & Observability**

#### **Logging Standards**
- **Structured Logging**: Use structured logging with consistent formats
- **Log Levels**: Implement appropriate log levels (DEBUG, INFO, WARN, ERROR)
- **Correlation IDs**: Use correlation IDs for request tracing
- **Performance Metrics**: Log performance metrics for analysis

#### **Error Handling**
- **Graceful Degradation**: Handle errors gracefully without crashing
- **User Feedback**: Provide meaningful error messages to users
- **Error Reporting**: Implement error reporting and monitoring
- **Recovery Mechanisms**: Implement automatic recovery where possible

---

**Remember**: Good documentation is not a one-time task - it's an ongoing commitment that requires attention with every change. Always README first, then implement, then update documentation.

**Expert Development**: Follow these standards to create production-ready, maintainable, and scalable applications that meet enterprise-grade requirements.
