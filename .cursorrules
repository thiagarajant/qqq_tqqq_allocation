# Cursor Rules for Stock Market Analysis Project

## üéØ **Core Principles**

1. **Always README First**: Before performing any task, read through ALL README.md files to understand the current project state
2. **Documentation-Driven Development**: Every change must be reflected in appropriate README files
3. **Consistency**: Maintain consistent formatting, structure, and information across all documentation
4. **Completeness**: Ensure all technical details, configurations, and procedures are documented

## üìö **Required Documentation Review**

### **Before Every Task**
1. **Read main README.md** - Understand project overview, architecture, and current status
2. **Read component READMEs** - Review frontend/README.md, backend/README.md, database/README.md
3. **Read DOCKER_README.md** - Understand containerization and deployment setup
4. **Read PROJECT_RESTRUCTURING_CONTEXT.md** - Know project history and current structure

### **Documentation Hierarchy**
```
README.md (Main project documentation)
‚îú‚îÄ‚îÄ frontend/README.md (Frontend component details)
‚îú‚îÄ‚îÄ backend/README.md (Backend component details)
‚îú‚îÄ‚îÄ database/README.md (Database schema and management)
‚îú‚îÄ‚îÄ DOCKER_README.md (Containerization and DevOps)
‚îî‚îÄ‚îÄ PROJECT_RESTRUCTURING_CONTEXT.md (Project history and status)
```

## üîÑ **Documentation Update Workflow**

### **When Making Changes**
1. **Identify Impact**: Determine which README files need updates
2. **Update Content**: Modify relevant documentation sections
3. **Verify Consistency**: Ensure information is consistent across all files
4. **Commit Changes**: Include documentation updates in the same commit as code changes

### **Update Triggers**
- **Code Changes**: New features, bug fixes, refactoring
- **Configuration Changes**: Environment variables, ports, dependencies
- **Architecture Changes**: New components, services, or integrations
- **Process Changes**: Build steps, deployment procedures, development workflows

## üìù **Documentation Standards**

### **File Structure**
- **Clear Headers**: Use consistent header hierarchy (##, ###, ####)
- **Code Blocks**: Proper syntax highlighting and formatting
- **Links**: Internal links between related documentation sections
- **Examples**: Include practical examples and code snippets

### **Content Requirements**
- **Current Status**: Always reflect the actual current state
- **Version Information**: Keep version numbers and dates updated
- **Dependencies**: Document all package versions and requirements
- **Configuration**: Include all necessary configuration steps
- **Troubleshooting**: Document common issues and solutions

## üöÄ **Task Execution Protocol**

### **Step 1: Documentation Review**
```bash
# Always start by reading these files:
1. README.md - Main project documentation
2. frontend/README.md - Frontend component details
3. backend/README.md - Backend component details
4. database/README.md - Database schema and management
5. DOCKER_README.md - Containerization setup
6. PROJECT_RESTRUCTURING_CONTEXT.md - Project history
```

### **Step 2: Docker-First Development**
- **Always use Docker**: All development, testing, and quality checks run in containers
- **Container Environment**: Ensure all tools work within Docker containers
- **Volume Mounts**: Use source code mounting for hot reload and live development
- **Multi-Service Testing**: Test complete system integration, not individual components

### **Step 3: Task Analysis**
- **Understand Requirements**: What needs to be accomplished?
- **Identify Scope**: Which components are affected?
- **Plan Documentation Updates**: Which README files need changes?
- **Docker Impact**: Which containers and services are affected?

### **Step 4: Implementation**
- **Make Code Changes**: Implement the requested functionality within Docker containers
- **Update Documentation**: Modify relevant README files
- **Verify Consistency**: Ensure all documentation is aligned
- **Container Testing**: Test changes in the containerized environment

### **Step 5: Validation**
- **Test Functionality**: Verify the changes work in Docker containers
- **Review Documentation**: Check that all updates are accurate
- **Container Health**: Ensure all services are running and healthy
- **Commit Changes**: Include both code and documentation updates

## üîç **Specific Documentation Areas**

### **Frontend Changes**
- **Update frontend/README.md** with:
  - New components or pages
  - Updated dependencies
  - Configuration changes
  - Build process modifications

### **Backend Changes**
- **Update backend/README.md** with:
  - New API endpoints
  - Database schema changes
  - Configuration updates
  - Performance optimizations

### **Database Changes**
- **Update database/README.md** with:
  - Schema modifications
  - New tables or views
  - Migration procedures
  - Performance improvements

### **Docker/DevOps Changes**
- **Update DOCKER_README.md** with:
  - New services or containers
  - Configuration changes
  - Build process updates
  - Deployment procedures

### **Project-Wide Changes**
- **Update main README.md** with:
  - Architecture changes
  - New features or capabilities
  - Updated quick start procedures
  - Modified project structure

## üìä **Documentation Quality Checklist**

### **Before Committing**
- [ ] All relevant README files have been updated
- [ ] Information is consistent across all documentation
- [ ] Examples and code snippets are current and working
- [ ] Version numbers and dates are updated
- [ ] Links between documentation files are working
- [ ] Configuration steps are complete and accurate
- [ ] Troubleshooting sections cover new issues

### **Content Validation**
- [ ] Technical details are accurate and current
- [ ] Step-by-step procedures are complete
- [ ] Code examples are syntax-correct and functional
- [ ] Configuration files reflect actual project state
- [ ] Dependencies and versions are current
- [ ] Port numbers and URLs are correct

## üö® **Common Documentation Pitfalls**

### **Avoid These Issues**
1. **Outdated Information**: Don't leave old configuration details
2. **Inconsistent Naming**: Use consistent terminology across all files
3. **Missing Examples**: Always provide practical usage examples
4. **Broken Links**: Ensure internal documentation links work
5. **Incomplete Procedures**: Don't leave steps incomplete

### **Best Practices**
1. **Update as You Go**: Don't wait until the end to update documentation
2. **Test Examples**: Verify that code examples actually work
3. **Cross-Reference**: Link related information between files
4. **Version Control**: Include documentation updates in the same commits as code changes

## üîß **Automated Documentation Tasks**

### **Regular Maintenance**
- **Weekly**: Review and update version numbers
- **Monthly**: Verify all links and examples are working
- **Quarterly**: Comprehensive review of all documentation
- **On Release**: Update all version information and release notes

### **Change Detection**
- **Package.json Changes**: Update dependency documentation
- **Docker Changes**: Update containerization documentation
- **API Changes**: Update backend and API documentation
- **UI Changes**: Update frontend and user interface documentation

## üìã **Task-Specific Rules**

### **For New Features**
1. Read all README files to understand current state
2. Implement the feature within Docker containers
3. Test the feature in the containerized environment
4. Update relevant component README files
5. Update main README.md if it's a major feature
6. Update PROJECT_RESTRUCTURING_CONTEXT.md with new status
7. Ensure Docker services are healthy and communicating

### **For Bug Fixes**
1. Read relevant README files to understand the issue
2. Fix the bug within Docker containers
3. Test the fix in the containerized environment
4. Update troubleshooting sections if needed
5. Update any configuration documentation if changed
6. Verify container health and service communication

### **For Refactoring**
1. Read all README files to understand current architecture
2. Perform the refactoring within Docker containers
3. Test the refactored code in the containerized environment
4. Update all affected documentation sections
5. Ensure new structure is properly documented
6. Verify container orchestration and service dependencies

### **For Configuration Changes**
1. Read relevant README files to understand current configuration
2. Make the configuration change in Docker Compose and container configs
3. Test the configuration in the containerized environment
4. Update all documentation that references the old configuration
5. Update examples and procedures as needed
6. Ensure container environment variables and networking are properly configured

## üéØ **Success Metrics**

### **Documentation Quality**
- **Completeness**: All features and procedures are documented
- **Accuracy**: Information matches actual project state
- **Consistency**: Terminology and format are consistent across files
- **Usability**: Documentation is easy to follow and understand

### **Maintenance**
- **Timeliness**: Documentation is updated with code changes
- **Version Control**: Documentation changes are committed with code
- **Review Process**: Regular documentation reviews are performed
- **User Feedback**: Documentation addresses user needs and questions

---

## üé® **Expert-Level Development Standards**

### **Frontend (React + TypeScript) Best Practices**

#### **React 18+ Patterns**
- **Functional Components**: Use functional components with hooks, avoid class components
- **Custom Hooks**: Extract reusable logic into custom hooks with descriptive names
- **Context API**: Use React Context for global state, avoid prop drilling
- **Strict Mode**: Enable React.StrictMode for development builds
- **Error Boundaries**: Implement error boundaries for graceful error handling
- **Suspense**: Use React.Suspense for lazy loading and data fetching

#### **TypeScript Excellence**
- **Strict Mode**: Enable all strict TypeScript compiler options
- **Type Definitions**: Create comprehensive interfaces and types for all data structures
- **Generic Types**: Use generics for reusable, type-safe components
- **Union Types**: Leverage union types for flexible but safe APIs
- **Utility Types**: Use TypeScript utility types (Partial, Pick, Omit, etc.)
- **No Any**: Avoid `any` type, use `unknown` or proper typing instead

#### **State Management**
- **Local State**: Use `useState` for component-local state
- **Complex State**: Use `useReducer` for complex state logic
- **Context**: Use Context API for theme, user preferences, global settings
- **External State**: Consider Zustand or Redux Toolkit for complex global state
- **State Updates**: Always use functional updates for state that depends on previous values

#### **Performance Optimization**
- **React.memo**: Memoize components that receive stable props
- **useMemo**: Memoize expensive calculations
- **useCallback**: Memoize callback functions passed to child components
- **Lazy Loading**: Use React.lazy and Suspense for code splitting
- **Virtual Scrolling**: Implement virtual scrolling for large lists
- **Bundle Analysis**: Regular bundle analysis and optimization

#### **Component Architecture**
- **Single Responsibility**: Each component should have one clear purpose
- **Composition**: Prefer composition over inheritance
- **Props Interface**: Define clear, minimal props interfaces
- **Default Props**: Use default props for optional values
- **Prop Validation**: Use TypeScript for runtime prop validation

### **Backend (Node.js + Express) Best Practices**

#### **Node.js Excellence**
- **Async/Await**: Use async/await instead of callbacks or promises
- **Error Handling**: Implement comprehensive error handling with try-catch
- **Streaming**: Use streams for large file operations and real-time data
- **Memory Management**: Monitor memory usage and implement garbage collection optimization
- **Cluster Mode**: Use Node.js cluster for multi-core utilization in production

#### **Express.js Patterns**
- **Middleware Chain**: Organize middleware in logical order
- **Route Organization**: Group related routes in separate files
- **Error Middleware**: Implement global error handling middleware
- **Request Validation**: Validate all incoming requests with Joi or similar
- **Response Formatting**: Standardize API response formats
- **Rate Limiting**: Implement rate limiting for API endpoints

#### **API Design**
- **RESTful Principles**: Follow REST conventions for API design
- **Versioning**: Implement API versioning strategy
- **Pagination**: Use cursor-based pagination for large datasets
- **Filtering**: Implement flexible filtering and sorting
- **Caching**: Use Redis or in-memory caching for frequently accessed data
- **Documentation**: Auto-generate API documentation with Swagger/OpenAPI

#### **Security Best Practices**
- **Input Validation**: Validate and sanitize all inputs
- **SQL Injection**: Use parameterized queries, never concatenate SQL
- **Authentication**: Implement JWT or session-based authentication
- **Authorization**: Use role-based access control (RBAC)
- **HTTPS**: Always use HTTPS in production
- **Security Headers**: Implement security headers with Helmet.js

### **Database (SQLite3) Best Practices**

#### **Schema Design**
- **Normalization**: Follow database normalization principles
- **Indexing Strategy**: Create strategic indexes for query performance
- **Constraints**: Use foreign keys, check constraints, and unique constraints
- **Views**: Create views for complex, frequently-used queries
- **Stored Procedures**: Use prepared statements for complex operations

#### **Performance Optimization**
- **Query Optimization**: Write efficient SQL queries with proper JOINs
- **Index Usage**: Monitor index usage and create missing indexes
- **Connection Pooling**: Implement connection pooling for concurrent access
- **Transaction Management**: Use transactions for data consistency
- **Batch Operations**: Use batch inserts/updates for large datasets

#### **Data Integrity**
- **ACID Compliance**: Ensure transactions are atomic, consistent, isolated, and durable
- **Backup Strategy**: Implement regular database backups
- **Migration System**: Use versioned database migrations
- **Data Validation**: Validate data at both application and database levels

### **DevOps & Infrastructure Best Practices**

#### **Docker Excellence**
- **Multi-stage Builds**: Use multi-stage builds for optimized images
- **Layer Caching**: Optimize Docker layer caching for faster builds
- **Security Scanning**: Scan images for vulnerabilities
- **Resource Limits**: Set appropriate CPU and memory limits
- **Health Checks**: Implement comprehensive health checks
- **Volume Mounts**: Use source code mounting for live development
- **Hot Reload**: Ensure frontend and backend hot reload in containers
- **Container Orchestration**: Use docker-compose for multi-service management
- **Development Profiles**: Separate development and production configurations
- **Container Networking**: Proper service communication and port mapping

#### **CI/CD Pipeline**
- **Containerized Testing**: Run all tests within Docker containers
- **Code Quality**: Use ESLint, Prettier, and TypeScript compiler checks in containers
- **Security Scanning**: Scan Docker images for vulnerabilities
- **Deployment Strategy**: Use blue-green or rolling deployments with containers
- **Monitoring**: Implement comprehensive logging and monitoring for containers
- **Container Registry**: Use Docker registry for image versioning and deployment
- **Infrastructure as Code**: Docker Compose for environment management

### **Code Quality Standards**

#### **Code Organization**
- **File Structure**: Organize code by feature, not by type
- **Naming Conventions**: Use descriptive, consistent naming
- **File Size**: Keep files under 300 lines when possible
- **Function Length**: Keep functions under 50 lines
- **Class Size**: Keep classes focused and small

#### **Code Review Standards**
- **Readability**: Code should be self-documenting
- **Performance**: Consider performance implications
- **Security**: Review for security vulnerabilities
- **Testing**: Ensure adequate test coverage
- **Documentation**: Verify inline documentation

#### **Testing Strategy**
- **Unit Tests**: 80%+ code coverage for critical paths
- **Integration Tests**: Test component interactions
- **E2E Tests**: Test critical user journeys
- **Performance Tests**: Test under load conditions
- **Security Tests**: Regular security testing

### **Performance & Scalability**

#### **Frontend Performance**
- **Bundle Optimization**: Minimize bundle size with tree shaking
- **Lazy Loading**: Implement lazy loading for routes and components
- **Image Optimization**: Use WebP format and responsive images
- **Caching Strategy**: Implement effective caching strategies
- **CDN Usage**: Use CDN for static assets

#### **Backend Performance**
- **Database Optimization**: Optimize database queries and indexes
- **Caching Layers**: Implement multiple caching layers
- **Load Balancing**: Use load balancing for horizontal scaling
- **Microservices**: Consider microservices for complex applications
- **Monitoring**: Implement comprehensive performance monitoring

### **Security Considerations**

#### **Frontend Security**
- **XSS Prevention**: Sanitize user inputs and use Content Security Policy
- **CSRF Protection**: Implement CSRF tokens for state-changing operations
- **Secure Storage**: Never store sensitive data in localStorage
- **HTTPS Only**: Ensure all communications use HTTPS

#### **Backend Security**
- **Input Validation**: Validate all inputs at multiple layers
- **Authentication**: Implement secure authentication mechanisms
- **Authorization**: Use principle of least privilege
- **Data Encryption**: Encrypt sensitive data at rest and in transit
- **Audit Logging**: Log all security-relevant events

### **Monitoring & Observability**

#### **Logging Standards**
- **Structured Logging**: Use structured logging with consistent formats
- **Log Levels**: Implement appropriate log levels (DEBUG, INFO, WARN, ERROR)
- **Correlation IDs**: Use correlation IDs for request tracing
- **Performance Metrics**: Log performance metrics for analysis

#### **Error Handling**
- **Graceful Degradation**: Handle errors gracefully without crashing
- **User Feedback**: Provide meaningful error messages to users
- **Error Reporting**: Implement error reporting and monitoring
- **Recovery Mechanisms**: Implement automatic recovery where possible

---

## üê≥ **Docker-First Development Workflow**

### **Daily Development Process**
1. **Start Development Environment**:
   ```bash
   docker-compose --profile dev up -d
   ```

2. **Make Code Changes**: Edit files locally, changes reflect in containers via volume mounts

3. **Test in Containers**: All testing and validation happens within Docker containers

4. **Quality Checks**: Run containerized quality checks and tests

5. **Integration Testing**: Test complete system in containerized environment

6. **Commit Changes**: Ensure all containers are healthy before committing

### **Container Health Monitoring**
- **Service Status**: Check `docker-compose ps` for all services
- **Health Checks**: Monitor container health endpoints
- **Logs**: Review container logs for errors and issues
- **Networking**: Verify service communication and port mapping

### **Development Commands**
```bash
# Start development environment
docker-compose --profile dev up -d

# View logs
docker-compose logs -f [service-name]

# Restart services
docker-compose restart [service-name]

# Rebuild containers
docker-compose up --build -d

# Stop all services
docker-compose down

# Check service health
docker-compose ps
```

---

**Remember**: Good documentation is not a one-time task - it's an ongoing commitment that requires attention with every change. Always README first, then implement in Docker containers, then update documentation.

**Expert Development**: Follow these standards to create production-ready, maintainable, and scalable applications that meet enterprise-grade requirements. All development, testing, and quality checks run within Docker containers for consistency and reliability.
